/*====================================================================*\

Pattern2Image.java

Class: Pattern 2 image.

\*====================================================================*/


// PACKAGE


package uk.blankaspect.patterngenerator;

//----------------------------------------------------------------------


// IMPORTS


import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;

import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Path2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;

import java.awt.image.BufferedImage;

import java.io.IOException;

import java.text.DecimalFormat;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import uk.blankaspect.common.exception.AppException;

import uk.blankaspect.common.exception2.UnexpectedRuntimeException;
import uk.blankaspect.common.exception2.ValueOutOfBoundsException;

import uk.blankaspect.common.misc.IStringKeyed;
import uk.blankaspect.common.misc.NoYes;

import uk.blankaspect.common.random.Prng01;

import uk.blankaspect.common.range.IntegerRange;

import uk.blankaspect.common.string.StringUtils;

import uk.blankaspect.common.ui.progress.IProgressView;

import uk.blankaspect.common.xml.Attribute;
import uk.blankaspect.common.xml.AttributeList;
import uk.blankaspect.common.xml.XmlParseException;
import uk.blankaspect.common.xml.XmlUtils;
import uk.blankaspect.common.xml.XmlWriter;

import uk.blankaspect.ui.swing.colour.ColourUtils;

//----------------------------------------------------------------------


// CLASS: PATTERN 2 IMAGE


class Pattern2Image
	extends PatternImage
	implements Cloneable
{

////////////////////////////////////////////////////////////////////////
//  Constants
////////////////////////////////////////////////////////////////////////

	public static final		int		MIN_ACTIVE_FRACTION		= 1;
	public static final		int		MAX_ACTIVE_FRACTION		= 100;
	public static final		int		DEFAULT_ACTIVE_FRACTION	= 50;

	public static final		int		MIN_TRANSITION_INTERVAL	= 1;
	public static final		int		MAX_TRANSITION_INTERVAL	= 600;

	public static final		IntegerRange	DEFAULT_TRANSITION_INTERVAL_RANGE	= new IntegerRange(50, 75);

	private static final	int		MIN_SUPPORTED_VERSION	= 0;
	private static final	int		MAX_SUPPORTED_VERSION	= 0;
	private static final	int		VERSION					= 0;

	private static final	double	MAX_CUMULATIVE_PROBABILITY	= 0.9999;

	private static final	double	INTERVAL_FACTOR	= 1.0 / StrictMath.sqrt(3.0);

	private static final	double	MIN_X_INTERVAL	= 0.0;
	private static final	double	MAX_X_INTERVAL	= 1000.0;

	private static final	double	MIN_Y_INTERVAL	= 0.0;
	private static final	double	MAX_Y_INTERVAL	= 1000.0;

	private static final	double	MIN_X_MARGIN	= 0.0;
	private static final	double	MAX_X_MARGIN	= 1000.0;

	private static final	double	MIN_Y_MARGIN	= 0.0;
	private static final	double	MAX_Y_MARGIN	= 1000.0;

	private static final	double	ACTIVE_FRACTION_FACTOR	= 100.0;

	private static final	int		NUM_RESERVED_SEEDS	= 16;

	private static final	int		PRNG_GENERAL			= 0;
	private static final	int		PRNG_TERMINAL_EMPHASIS	= 1;
	private static final	int		PRNG_COLOUR				= 2;
	private static final	int		PRNG_TRANSITION_LENGTH	= 3;
	private static final	int		PRNG_ANIMATION			= NUM_RESERVED_SEEDS - 1;

	private static final	String	CLIP_STR			= "clip";
	private static final	String	CLIP_PATH_REF_STR	= "url(#" + CLIP_STR + ")";
	private static final	String	PATH_STYLE_STR		= "pathStyle";
	private static final	String	TEXT_CSS_STR		= "text/css";
	private static final	String	BACKGROUND_STR		= "background";
	private static final	String	FOREGROUND_STR		= "foreground";
	private static final	String	GENERATED_BY_STR	= "Generated by ";

	private static final	String[]	PATH_STYLE_STRS	=
	{
		"<![CDATA[",
		"  g#foreground > path",
		"  {",
		"    fill: none;",
		"    stroke-width: %s;",
		"    stroke-linecap: round;",
		"    stroke-linejoin: round;",
		"  }",
		"]]>"
	};

	private interface ElementName
	{
		String	PATH	= "path";
	}

	private interface AttrName
	{
		String	BACKGROUND_COLOUR	= "backgroundColour";
		String	DESCRIPTION			= "description";
		String	HEIGHT				= "height";
		String	NUM_PATHS			= "numPaths";
		String	ORIENTATION			= "orientation";
		String	PATH_THICKNESS		= "pathThickness";
		String	SHOW_EMPTY_PATHS	= "showEmptyPaths";
		String	TERMINAL_DIAMETER	= "terminalDiameter";
		String	TRANSPARENCY_COLOUR	= "transparencyColour";
		String	VERSION				= "version";
		String	WIDTH				= "width";
		String	X_INTERVAL			= "xInterval";
		String	X_MARGIN			= "xMargin";
		String	Y_INTERVAL			= "yInterval";
		String	Y_MARGIN			= "yMargin";
	}

	private static final	Map<Direction, Double>	CUMULATIVE_EQUAL_PROBABILITIES;

////////////////////////////////////////////////////////////////////////
//  Enumerated types
////////////////////////////////////////////////////////////////////////


	// ORIENTATION


	enum Orientation
		implements IStringKeyed
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		UP
		(
			"up"
		),

		DOWN
		(
			"down"
		),

		LEFT
		(
			"left"
		),

		RIGHT
		(
			"right"
		);

		//--------------------------------------------------------------

		private static final	Set<Orientation>	VERTICAL_ORIENTATIONS	= EnumSet.of
		(
			UP,
			DOWN
		);

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private Orientation(String key)
		{
			this.key = key;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Class methods
	////////////////////////////////////////////////////////////////////

		public static Orientation forKey(String key)
		{
			for (Orientation value : values())
			{
				if (value.key.equals(key))
					return value;
			}
			return null;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : IStringKeyed interface
	////////////////////////////////////////////////////////////////////

		public String getKey()
		{
			return key;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : overriding methods
	////////////////////////////////////////////////////////////////////

		@Override
		public String toString()
		{
			return StringUtils.firstCharToUpperCase(key);
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods
	////////////////////////////////////////////////////////////////////

		public boolean isVertical()
		{
			return VERTICAL_ORIENTATIONS.contains(this);
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	String	key;

	}

	//==================================================================


	// DIRECTION


	enum Direction
		implements IStringKeyed
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		FORE
		(
			"fore",
			"F",
			2, 0
		),

		FORE_RIGHT
		(
			"foreRight",
			"FR",
			1, 1
		),

		BACK_RIGHT
		(
			"backRight",
			"BR",
			-1, 1
		),

		BACK
		(
			"back",
			"B",
			-2, 0
		),

		BACK_LEFT
		(
			"backLeft",
			"BL",
			-1, -1
		),

		FORE_LEFT
		(
			"foreLeft",
			"FL",
			1, -1
		);

		//--------------------------------------------------------------

		public static final	int	NUM_VALUES	= values().length;

	////////////////////////////////////////////////////////////////////
	//  Enumerated types
	////////////////////////////////////////////////////////////////////


		// DIRECTION MODE


		enum Mode
			implements IStringKeyed
		{

		////////////////////////////////////////////////////////////////
		//  Constants
		////////////////////////////////////////////////////////////////

			ABSOLUTE
			(
				"absolute"
			),

			RELATIVE
			(
				"relative"
			);

		////////////////////////////////////////////////////////////////
		//  Constructors
		////////////////////////////////////////////////////////////////

			private Mode(String key)
			{
				this.key = key;
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance methods : IStringKeyed interface
		////////////////////////////////////////////////////////////////

			public String getKey()
			{
				return key;
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance methods : overriding methods
		////////////////////////////////////////////////////////////////

			@Override
			public String toString()
			{
				return StringUtils.firstCharToUpperCase(key);
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance variables
		////////////////////////////////////////////////////////////////

			private	String	key;

		}

		//==============================================================

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private Direction(String key,
						  String shortText,
						  int    delta0,
						  int    delta1)
		{
			this.key = key;
			this.shortText = shortText;
			this.delta0 = delta0;
			this.delta1 = delta1;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Class methods
	////////////////////////////////////////////////////////////////////

		public static Direction forKey(String key)
		{
			for (Direction value : values())
			{
				if (value.key.equals(key))
					return value;
			}
			return null;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : IStringKeyed interface
	////////////////////////////////////////////////////////////////////

		public String getKey()
		{
			return key;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods
	////////////////////////////////////////////////////////////////////

		public String getShortText()
		{
			return shortText;
		}

		//--------------------------------------------------------------

		public int incrementIndex0(int i0)
		{
			return (i0 + delta0);
		}

		//--------------------------------------------------------------

		public int incrementIndex1(int i1)
		{
			return (i1 + delta1);
		}

		//--------------------------------------------------------------

		public Direction getReflection()
		{
			Direction direction = null;
			switch (this)
			{
				case FORE:
					// do nothing
					break;

				case FORE_RIGHT:
					direction = FORE_LEFT;
					break;

				case BACK_RIGHT:
					direction = BACK_LEFT;
					break;

				case BACK:
					// do nothing
					break;

				case BACK_LEFT:
					direction = BACK_RIGHT;
					break;

				case FORE_LEFT:
					direction = FORE_RIGHT;
					break;
			}
			return direction;
		}

		//--------------------------------------------------------------

		public Direction getInverse()
		{
			return values()[(ordinal() + NUM_VALUES / 2) % NUM_VALUES];
		}

		//--------------------------------------------------------------

		public Direction add(Direction direction)
		{
			return values()[(ordinal() + direction.ordinal()) % NUM_VALUES];
		}

		//--------------------------------------------------------------

		public Direction subtract(Direction direction)
		{
			return values()[(ordinal() + (NUM_VALUES - direction.ordinal())) % NUM_VALUES];
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	String	key;
		private	String	shortText;
		private	int		delta0;
		private	int		delta1;

	}

	//==================================================================


	// TERMINAL EMPHASIS


	enum TerminalEmphasis
		implements IStringKeyed
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		NONE
		(
			"none",
			"None"
		),

		START
		(
			"start",
			"Start"
		),

		END
		(
			"end",
			"End"
		),

		START_AND_END
		(
			"startAndEnd",
			"Start and end"
		),

		RANDOM
		(
			"random",
			"Random"
		),

		RANDOM_ONE_ONLY
		(
			"randomOneOnly",
			"Random, one only"
		),

		RANDOM_AT_LEAST_ONE
		(
			"randomAtLeastOne",
			"Random, at least one"
		);

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private TerminalEmphasis(String key,
								 String text)
		{
			this.key = key;
			this.text = text;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : IStringKeyed interface
	////////////////////////////////////////////////////////////////////

		public String getKey()
		{
			return key;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : overriding methods
	////////////////////////////////////////////////////////////////////

		@Override
		public String toString()
		{
			return text;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	String	key;
		private	String	text;

	}

	//==================================================================


	// PATH RENDERING


	enum PathRendering
		implements IStringKeyed
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		PURE
		(
			"pure",
			RenderingHints.VALUE_STROKE_PURE
		),

		NORMALISED
		(
			"normalised",
			RenderingHints.VALUE_STROKE_NORMALIZE
		);

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private PathRendering(String key,
							  Object renderingHintValue)
		{
			this.key = key;
			this.renderingHintValue = renderingHintValue;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : IStringKeyed interface
	////////////////////////////////////////////////////////////////////

		public String getKey()
		{
			return key;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : overriding methods
	////////////////////////////////////////////////////////////////////

		@Override
		public String toString()
		{
			return StringUtils.firstCharToUpperCase(key);
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	String	key;
		private	Object	renderingHintValue;

	}

	//==================================================================


	// ERROR IDENTIFIERS


	private enum ErrorId
		implements AppException.IId
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		UNSUPPORTED_VERSION
		("The version of %1 is not supported by this version of " + PatternGeneratorApp.SHORT_NAME + "."),

		NO_ATTRIBUTE
		("The required attribute is missing."),

		INVALID_ATTRIBUTE
		("The attribute is invalid."),

		ATTRIBUTE_OUT_OF_BOUNDS
		("The attribute value is out of bounds."),

		INVALID_DIRECTION
		("The direction is invalid."),

		INCONSISTENT_NUMBER_OF_PATHS
		("The attribute value is not consistent with the number of path elements.");

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private ErrorId(String message)
		{
			this.message = message;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : AppException.IId interface
	////////////////////////////////////////////////////////////////////

		public String getMessage()
		{
			return message;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	String	message;

	}

	//==================================================================

////////////////////////////////////////////////////////////////////////
//  Member classes : non-inner classes
////////////////////////////////////////////////////////////////////////


	// CLASS: PATH


	private static class Path
		implements Cloneable
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		private static final	int	MIN_I0	= 0;
		private static final	int	MAX_I0	= 10000;

		private static final	int	MIN_I1	= 0;
		private static final	int	MAX_I1	= 10000;

		private static final	Comparator<Path>	LENGTH_COMPARATOR =
				Comparator.<Path>comparingInt(Path::getLength)
						.thenComparing(Comparator.<Path>comparingInt(path ->
								Math.max(path.start.lengthenFrameIndex, path.end.lengthenFrameIndex)).reversed());

		private enum Change
		{
			NONE,
			LENGTHEN,
			SHORTEN
		}

		private interface ElementName
		{
			String	DIRECTION	= "direction";
		}

		private interface AttrName
		{
			String	COLOUR			= "colour";
			String	EMPHASISE_END	= "emphasiseEnd";
			String	EMPHASISE_START	= "emphasiseStart";
			String	I0				= "i0";
			String	I1				= "i1";
		}

	////////////////////////////////////////////////////////////////////
	//  Member classes : non-inner classes
	////////////////////////////////////////////////////////////////////


		// TERMINAL CLASS


		private static class Terminal
			implements Cloneable
		{

		////////////////////////////////////////////////////////////////
		//  Constants
		////////////////////////////////////////////////////////////////

			private enum Kind
			{
				START,
				END
			}

		////////////////////////////////////////////////////////////////
		//  Constructors
		////////////////////////////////////////////////////////////////

			private Terminal(Path path,
							 Kind kind,
							 int  i0,
							 int  i1)
			{
				this.path = path;
				this.kind = kind;
				this.i0 = i0;
				this.i1 = i1;
				change = Change.NONE;
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance methods : overriding methods
		////////////////////////////////////////////////////////////////

			@Override
			public Terminal clone()
			{
				try
				{
					return (Terminal)super.clone();
				}
				catch (CloneNotSupportedException e)
				{
					throw new UnexpectedRuntimeException(e);
				}
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance methods
		////////////////////////////////////////////////////////////////

			private boolean isAt(int i0,
								 int i1)
			{
				return ((this.i0 == i0) && (this.i1 == i1));
			}

			//----------------------------------------------------------

			private void applyDirection(Direction direction)
			{
				i0 = direction.incrementIndex0(i0);
				i1 = direction.incrementIndex1(i1);
			}

			//----------------------------------------------------------

			private Change update(int frameIndex)
			{
				Change oldChange = null;
				if (change != Change.NONE)
				{
					if (frameIndex < startFrameIndex + transitionLength)
					{
						changeFraction = (double)(frameIndex - startFrameIndex) / (double)transitionLength;
						switch (change)
						{
							case NONE:
								// do nothing
								break;

							case LENGTHEN:
								if0 = (double)j0 + (double)(i0 - j0) * changeFraction;
								if1 = (double)j1 + (double)(i1 - j1) * changeFraction;
								break;

							case SHORTEN:
								if0 = (double)i0 + (double)(j0 - i0) * changeFraction;
								if1 = (double)i1 + (double)(j1 - i1) * changeFraction;
								break;
						}
					}
					else
					{
						oldChange = change;
						if (change == Change.SHORTEN)
						{
							i0 = j0;
							i1 = j1;
						}
						change = Change.NONE;
					}
				}
				return oldChange;
			}

			//----------------------------------------------------------

			private void create(int frameIndex,
								int transitionLength)
			{
				change = Path.Change.LENGTHEN;
				startFrameIndex = frameIndex;
				this.transitionLength = transitionLength;
				j0 = i0;
				j1 = i1;
				update(frameIndex);
			}

			//----------------------------------------------------------

			private void destroy(int frameIndex,
								 int transitionLength)
			{
				change = Path.Change.SHORTEN;
				startFrameIndex = frameIndex;
				this.transitionLength = transitionLength;
				j0 = i0;
				j1 = i1;
				update(frameIndex);
			}

			//----------------------------------------------------------

			private void lengthen(int       frameIndex,
								  int       transitionLength,
								  Direction direction)
			{
				change = Path.Change.LENGTHEN;
				startFrameIndex = frameIndex;
				lengthenFrameIndex = frameIndex;
				this.transitionLength = transitionLength;
				j0 = i0;
				j1 = i1;
				i0 = direction.incrementIndex0(i0);
				i1 = direction.incrementIndex1(i1);
				update(frameIndex);
			}

			//----------------------------------------------------------

			private void shorten(int       frameIndex,
								 int       transitionLength,
								 Direction direction)
			{
				change = Path.Change.SHORTEN;
				startFrameIndex = frameIndex;
				this.transitionLength = transitionLength;
				j0 = direction.incrementIndex0(i0);
				j1 = direction.incrementIndex1(i1);
				update(frameIndex);
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance variables
		////////////////////////////////////////////////////////////////

			private	Path	path;
			private	Kind	kind;
			private	int		i0;
			private	int		i1;
			private	boolean	emphasise;
			private	Change	change;
			private	int		startFrameIndex;
			private	int		lengthenFrameIndex;
			private	int		transitionLength;
			private	int		j0;
			private	int		j1;
			private	double	changeFraction;
			private	double	if0;
			private	double	if1;

		}

		//==============================================================

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		private Path(int i0,
					 int i1)
		{
			start = new Terminal(this, Terminal.Kind.START, i0, i1);
			end = new Terminal(this, Terminal.Kind.END, i0, i1);
			directions = new ArrayList<>();
		}

		//--------------------------------------------------------------

		private Path(Element element)
			throws XmlParseException
		{
			// Get element path
			String elementPath = XmlUtils.getElementPath(element);

			// Attribute: i0
			String attrName = AttrName.I0;
			String attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
			String attrValue = XmlUtils.getAttribute(element, attrName);
			if (attrValue == null)
				throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
			int i0 = 0;
			try
			{
				i0 = Integer.parseInt(attrValue);
				if ((i0 < MIN_I0) || (i0 > MAX_I0))
					throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
			}
			catch (NumberFormatException e)
			{
				throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
			}

			// Attribute: i1
			attrName = AttrName.I1;
			attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
			attrValue = XmlUtils.getAttribute(element, attrName);
			if (attrValue == null)
				throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
			int i1 = 0;
			try
			{
				i1 = Integer.parseInt(attrValue);
				if ((i1 < MIN_I1) || (i1 > MAX_I1))
					throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
			}
			catch (NumberFormatException e)
			{
				throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
			}

			// Initialise start and end
			start = new Terminal(this, Terminal.Kind.START, i0, i1);
			end = new Terminal(this, Terminal.Kind.END, i0, i1);

			// Attribute: emphasise start
			attrName = AttrName.EMPHASISE_START;
			attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
			attrValue = XmlUtils.getAttribute(element, attrName);
			if (attrValue != null)
			{
				NoYes ny = NoYes.forKey(attrValue);
				if (ny == null)
					throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
				start.emphasise = ny.toBoolean();
			}

			// Attribute: emphasise end
			attrName = AttrName.EMPHASISE_END;
			attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
			attrValue = XmlUtils.getAttribute(element, attrName);
			if (attrValue != null)
			{
				NoYes ny = NoYes.forKey(attrValue);
				if (ny == null)
					throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
				end.emphasise = ny.toBoolean();
			}

			// Attribute: colour
			attrName = AttrName.COLOUR;
			attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
			attrValue = XmlUtils.getAttribute(element, attrName);
			if (attrValue == null)
				throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
			try
			{
				colour = ColourUtils.parseColour(attrValue);
			}
			catch (IllegalArgumentException e)
			{
				throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
			}
			catch (ValueOutOfBoundsException e)
			{
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
			}

			// Parse direction elements
			directions = new ArrayList<>();
			NodeList childNodes = element.getChildNodes();
			for (int i = 0; i < childNodes.getLength(); i++)
			{
				Node node = childNodes.item(i);
				if (node.getNodeType() == Node.ELEMENT_NODE)
				{
					Element element1 = (Element)node;
					if (element1.getTagName().equals(ElementName.DIRECTION))
					{
						String str = element1.getTextContent();
						Direction direction = Direction.forKey(str);
						if (direction == null)
							throw new XmlParseException(ErrorId.INVALID_DIRECTION,
														XmlUtils.getElementPath(element1), str);
						addDirection(direction);
					}
				}
			}
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods : overriding methods
	////////////////////////////////////////////////////////////////////

		@Override
		public Path clone()
		{
			try
			{
				Path copy = (Path)super.clone();

				copy.start = start.clone();
				copy.start.path = copy;

				copy.end = end.clone();
				copy.end.path = copy;

				copy.colour = ColourUtils.copy(colour);

				copy.directions = new ArrayList<>(directions);

				return copy;
			}
			catch (CloneNotSupportedException e)
			{
				throw new UnexpectedRuntimeException(e);
			}
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance methods
	////////////////////////////////////////////////////////////////////

		private boolean isEmpty()
		{
			return directions.isEmpty();
		}

		//--------------------------------------------------------------

		private boolean isChanging()
		{
			return ((start.change != Change.NONE) || (end.change != Change.NONE));
		}

		//--------------------------------------------------------------

		private int getLength()
		{
			return directions.size();
		}

		//--------------------------------------------------------------

		private Direction getFirstDirection()
		{
			return directions.get(0);
		}

		//--------------------------------------------------------------

		private Direction getLastDirection()
		{
			return directions.get(directions.size() - 1);
		}

		//--------------------------------------------------------------

		private void addDirection(Direction direction)
		{
			directions.add(direction);
			end.applyDirection(direction);
		}

		//--------------------------------------------------------------

		private void setTerminalEmphasis(TerminalEmphasis terminalEmphasis,
										 Prng01           prng)
		{
			switch (terminalEmphasis)
			{
				case NONE:
					// do nothing
					break;

				case START:
					start.emphasise = true;
					break;

				case END:
					end.emphasise = true;
					break;

				case START_AND_END:
					start.emphasise = true;
					end.emphasise = true;
					break;

				case RANDOM:
					if (prng.nextBoolean())
						start.emphasise = true;
					if (prng.nextBoolean())
						end.emphasise = true;
					break;

				case RANDOM_ONE_ONLY:
					if (prng.nextBoolean())
						start.emphasise = true;
					else
						end.emphasise = true;
					break;

				case RANDOM_AT_LEAST_ONE:
					if (prng.nextBoolean())
					{
						start.emphasise = true;
						end.emphasise = true;
					}
					else if (prng.nextBoolean())
						start.emphasise = true;
					else
						end.emphasise = true;
					break;
			}
		}

		//--------------------------------------------------------------

		private void setColour(List<Color> colours,
							   Prng01      prng)
		{
			colour = colours.get(prng.nextInt(colours.size()));
		}

		//--------------------------------------------------------------

		private Element createElement(Document document)
		{
			Element element = document.createElement(Pattern2Image.ElementName.PATH);
			for (Attribute attribute : getAttributes())
				attribute.set(element);

			for (Direction direction : directions)
			{
				Element directionElement = document.createElement(ElementName.DIRECTION);
				directionElement.setTextContent(direction.getKey());
				element.appendChild(directionElement);
			}

			return element;
		}

		//--------------------------------------------------------------

		private void write(XmlWriter writer,
						   int       indent)
			throws IOException
		{
			if (directions.isEmpty())
				writer.writeEmptyElement(Pattern2Image.ElementName.PATH, getAttributes(), indent, true);
			else
			{
				writer.writeElementStart(Pattern2Image.ElementName.PATH, getAttributes(), indent, true,
										 true);
				indent += XmlWriter.INDENT_INCREMENT;

				for (Direction direction : directions)
				{
					writer.writeElementStart(ElementName.DIRECTION, null, indent, false, false);
					writer.write(direction.getKey());
					writer.writeElementEnd(ElementName.DIRECTION, 0);
				}

				indent -= XmlWriter.INDENT_INCREMENT;
				writer.writeElementEnd(Pattern2Image.ElementName.PATH, indent);
			}
		}

		//--------------------------------------------------------------

		private AttributeList getAttributes()
		{
			AttributeList attributes = new AttributeList();
			attributes.add(AttrName.I0, start.i0);
			attributes.add(AttrName.I1, start.i1);
			attributes.add(AttrName.EMPHASISE_START, start.emphasise);
			attributes.add(AttrName.EMPHASISE_END, end.emphasise);
			attributes.add(AttrName.COLOUR, ColourUtils.colourToRgbString(colour));
			return attributes;
		}

		//--------------------------------------------------------------

		private void create(int frameIndex,
							int transitionLength)
		{
			start.create(frameIndex, transitionLength);
			end.create(frameIndex, transitionLength);
		}

		//--------------------------------------------------------------

		private void destroy(int frameIndex,
							 int transitionLength)
		{
			start.destroy(frameIndex, transitionLength);
			end.destroy(frameIndex, transitionLength);
		}

		//--------------------------------------------------------------

		private boolean update(int frameIndex)
		{
			boolean empty = directions.isEmpty();
			boolean destroyed = false;
			if (start.update(frameIndex) == Change.SHORTEN)
			{
				if (empty)
					destroyed = true;
				else
					directions.remove(0);
			}
			if (end.update(frameIndex) == Change.SHORTEN)
			{
				if (empty)
					destroyed = true;
				else
					directions.remove(directions.size() - 1);
			}
			return destroyed;
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		private	Terminal		start;
		private	Terminal		end;
		private	Color			colour;
		private	List<Direction>	directions;

	}

	//==================================================================


	// OUTPUT SHAPE CLASS


	private static abstract class OutputShape
	{

	////////////////////////////////////////////////////////////////////
	//  Constants
	////////////////////////////////////////////////////////////////////

		private static final	int	MAX_NUM_VERTICES_PER_LINE	= 4;

		private static final	String	MOVETO_PREFIX	= "M";
		private static final	String	LINETO_PREFIX	= "L";

		private static final	DecimalFormat	FORMAT	= AppConstants.FORMAT_1_8;

	////////////////////////////////////////////////////////////////////
	//  Member classes : non-inner classes
	////////////////////////////////////////////////////////////////////


		// POLYLINE CLASS


		private static class Polyline
			extends OutputShape
		{

		////////////////////////////////////////////////////////////////
		//  Constructors
		////////////////////////////////////////////////////////////////

			private Polyline(Color  colour,
							 double x,
							 double y)
			{
				this.colour = colour;
				path = new Path2D.Double();
				path.moveTo(x, y);
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance methods : overriding methods
		////////////////////////////////////////////////////////////////

			protected void draw(Graphics2D gr)
			{
				gr.setColor(colour);
				gr.draw(path);
			}

			//----------------------------------------------------------

			protected void transform(AffineTransform transform)
			{
				path.transform(transform);
			}

			//----------------------------------------------------------

			protected void writeSvg(XmlWriter writer,
									int       indent)
				throws IOException
			{
				StringBuilder buffer = new StringBuilder(256);
				int numSpaces = indent + 1 + ElementName.PATH.length() + 1 + Svg.AttrName.D.length() + 2;
				String spaces = " ".repeat(numSpaces);
				PathIterator it = path.getPathIterator(null);
				double[] coords = new double[6];
				int vertexCount = 0;
				while (!it.isDone())
				{
					switch (it.currentSegment(coords))
					{
						case PathIterator.SEG_MOVETO:
							buffer.append(MOVETO_PREFIX);
							break;

						case PathIterator.SEG_LINETO:
							if (vertexCount < MAX_NUM_VERTICES_PER_LINE)
								buffer.append(' ');
							else
							{
								buffer.append('\n');
								buffer.append(spaces);
								vertexCount = 0;
							}
							buffer.append(LINETO_PREFIX);
							break;
					}
					buffer.append(' ');
					buffer.append(FORMAT.format(coords[0]));
					buffer.append(' ');
					buffer.append(FORMAT.format(coords[1]));

					++vertexCount;
					it.next();
				}

				AttributeList attributes = new AttributeList();
				attributes.add(Svg.AttrName.STROKE, ColourUtils.colourToHexString(colour));
				if (ColourUtils.isTransparent(colour))
					attributes.add(Svg.AttrName.STROKE_OPACITY, ColourUtils.getOpacity(colour),
								   ColourUtils.OPACITY_FORMAT);
				attributes.add(Svg.AttrName.D, buffer);
				writer.writeEmptyElement(ElementName.PATH, attributes, indent, true);
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance methods
		////////////////////////////////////////////////////////////////

			private void add(double x,
							 double y)
			{
				path.lineTo(x, y);
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance variables
		////////////////////////////////////////////////////////////////

			private	Path2D.Double	path;

		}

		//==============================================================


		// DISC CLASS


		private static class Disc
			extends OutputShape
		{

		////////////////////////////////////////////////////////////////
		//  Constructors
		////////////////////////////////////////////////////////////////

			private Disc(Color  colour,
						 double x,
						 double y,
						 double diameter)
			{
				this.colour = colour;
				double radius = 0.5 * diameter;
				disc = new Ellipse2D.Double(x - radius, y - radius, diameter, diameter);
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance methods : overriding methods
		////////////////////////////////////////////////////////////////

			protected void draw(Graphics2D gr)
			{
				gr.setColor(colour);
				gr.fill(disc);
			}

			//----------------------------------------------------------

			protected void transform(AffineTransform transform)
			{
				double radius = 0.5 * disc.width;
				Point2D.Double point = new Point2D.Double(disc.x + radius, disc.y + radius);
				transform.transform(point, point);
				disc.x = point.x - radius;
				disc.y = point.y - radius;
			}

			//----------------------------------------------------------

			protected void writeSvg(XmlWriter writer,
									int       indent)
				throws IOException
			{
				double radius = 0.5 * disc.width;

				AttributeList attributes = new AttributeList();
				attributes.add(Svg.AttrName.FILL, ColourUtils.colourToHexString(colour));
				attributes.add(Svg.AttrName.CX, FORMAT.format(disc.x + radius));
				attributes.add(Svg.AttrName.CY, FORMAT.format(disc.y + radius));
				attributes.add(Svg.AttrName.R, FORMAT.format(radius));
				writer.writeEmptyElement(Svg.ElementName.CIRCLE, attributes, indent, true);
			}

			//----------------------------------------------------------

		////////////////////////////////////////////////////////////////
		//  Instance variables
		////////////////////////////////////////////////////////////////

			private	Ellipse2D.Double	disc;

		}

		//==============================================================

	////////////////////////////////////////////////////////////////////
	//  Constructors
	////////////////////////////////////////////////////////////////////

		protected OutputShape()
		{
		}

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Abstract methods
	////////////////////////////////////////////////////////////////////

		protected abstract void draw(Graphics2D gr);

		//--------------------------------------------------------------

		protected abstract void transform(AffineTransform transform)
			throws IOException;

		//--------------------------------------------------------------

		protected abstract void writeSvg(XmlWriter writer,
										 int       indent)
			throws IOException;

		//--------------------------------------------------------------

	////////////////////////////////////////////////////////////////////
	//  Instance variables
	////////////////////////////////////////////////////////////////////

		protected	Color	colour;

	}

	//==================================================================

////////////////////////////////////////////////////////////////////////
//  Constructors
////////////////////////////////////////////////////////////////////////

	public Pattern2Image(Pattern2Document document,
						 Element          element)
		throws XmlParseException
	{
		// Initialise instance variables
		this.document = document;

		// Get element path
		String elementPath = XmlUtils.getElementPath(element);

		// Attribute: version
		String attrName = AttrName.VERSION;
		String attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		String attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			int version = Integer.parseInt(attrValue);
			if ((version < MIN_SUPPORTED_VERSION) || (version > MAX_SUPPORTED_VERSION))
				throw new XmlParseException(ErrorId.UNSUPPORTED_VERSION, attrKey, attrValue,
											PatternKind.PATTERN2.toString());
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}

		// Attribute: description
		attrName = AttrName.DESCRIPTION;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue != null)
			description = attrValue;

		// Attribute: width
		attrName = AttrName.WIDTH;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			width = Integer.parseInt(attrValue);
			if ((width < Pattern2Params.MIN_WIDTH) || (width > Pattern2Params.MAX_WIDTH))
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}

		// Attribute: height
		attrName = AttrName.HEIGHT;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			height = Integer.parseInt(attrValue);
			if ((height < Pattern2Params.MIN_HEIGHT) || (height > Pattern2Params.MAX_HEIGHT))
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}

		// Attribute: orientation
		attrName = AttrName.ORIENTATION;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		orientation = Orientation.forKey(attrValue);
		if (orientation == null)
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);

		// Attribute: x interval
		attrName = AttrName.X_INTERVAL;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			xInterval = Double.parseDouble(attrValue);
			if ((xInterval < MIN_X_INTERVAL) || (xInterval > MAX_X_INTERVAL))
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}

		// Attribute: y interval
		attrName = AttrName.Y_INTERVAL;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			yInterval = Double.parseDouble(attrValue);
			if ((yInterval < MIN_Y_INTERVAL) || (yInterval > MAX_Y_INTERVAL))
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}

		// Attribute: x margin
		attrName = AttrName.X_MARGIN;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			xMargin = Double.parseDouble(attrValue);
			if ((xMargin < MIN_X_MARGIN) || (xMargin > MAX_X_MARGIN))
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}

		// Attribute: y margin
		attrName = AttrName.Y_MARGIN;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			yMargin = Double.parseDouble(attrValue);
			if ((yMargin < MIN_Y_MARGIN) || (yMargin > MAX_Y_MARGIN))
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}

		// Attribute: path thickness
		attrName = AttrName.PATH_THICKNESS;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			pathThickness = Double.parseDouble(attrValue);
			if ((pathThickness < Pattern2Params.MIN_PATH_THICKNESS) ||
				 (pathThickness > Pattern2Params.MAX_PATH_THICKNESS))
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}

		// Attribute: terminal diameter
		attrName = AttrName.TERMINAL_DIAMETER;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			terminalDiameter = Double.parseDouble(attrValue);
			if ((terminalDiameter < Pattern2Params.MIN_TERMINAL_DIAMETER) ||
				 (terminalDiameter > Pattern2Params.MAX_TERMINAL_DIAMETER))
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}

		// Attribute: show empty paths
		attrName = AttrName.SHOW_EMPTY_PATHS;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		NoYes ny = NoYes.forKey(attrValue);
		if (ny == null)
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		showEmptyPaths = ny.toBoolean();

		// Attribute: transparency colour
		attrName = AttrName.TRANSPARENCY_COLOUR;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			transparencyColour = Pattern2Params.DEFAULT_TRANSPARENCY_COLOUR;
		else
		{
			try
			{
				transparencyColour = ColourUtils.opaque(ColourUtils.parseColour(attrValue));
			}
			catch (IllegalArgumentException e)
			{
				throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
			}
			catch (ValueOutOfBoundsException e)
			{
				throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
			}
		}

		// Attribute: background colour
		attrName = AttrName.BACKGROUND_COLOUR;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			backgroundColour = ColourUtils.parseColour(attrValue);
		}
		catch (IllegalArgumentException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}
		catch (ValueOutOfBoundsException e)
		{
			throw new XmlParseException(ErrorId.ATTRIBUTE_OUT_OF_BOUNDS, attrKey, attrValue);
		}

		// Parse path elements
		paths = new ArrayList<>();
		NodeList childNodes = element.getChildNodes();
		for (int i = 0; i < childNodes.getLength(); i++)
		{
			Node node = childNodes.item(i);
			if (node.getNodeType() == Node.ELEMENT_NODE)
			{
				Element element1 = (Element)node;
				if (element1.getTagName().equals(ElementName.PATH))
					paths.add(new Path(element1));
			}
		}

		// Attribute: number of paths
		attrName = AttrName.NUM_PATHS;
		attrKey = XmlUtils.appendAttributeName(elementPath, attrName);
		attrValue = XmlUtils.getAttribute(element, attrName);
		if (attrValue == null)
			throw new XmlParseException(ErrorId.NO_ATTRIBUTE, attrKey);
		try
		{
			int numPaths = Integer.parseInt(attrValue);
			if (paths.size() != numPaths)
				throw new XmlParseException(ErrorId.INCONSISTENT_NUMBER_OF_PATHS, attrKey, attrValue);
		}
		catch (NumberFormatException e)
		{
			throw new XmlParseException(ErrorId.INVALID_ATTRIBUTE, attrKey, attrValue);
		}
	}

	//------------------------------------------------------------------

	public Pattern2Image(Pattern2Document document,
						 Pattern2Params   params)
		throws InterruptedException
	{
		// Initialise margins and intervals
		int margin0 = params.getEndMargin();
		int margin1 = params.getSideMargin();
		double interval1 = params.getGridInterval();
		double interval0 = interval1 * INTERVAL_FACTOR;

		// Initialise instance variables
		this.document = document;
		width = params.getWidth();
		height = params.getHeight();
		orientation = params.getOrientation();
		xInterval = orientation.isVertical() ? interval1 : interval0;
		yInterval = orientation.isVertical() ? interval0 : interval1;
		xMargin = orientation.isVertical() ? (double)margin1 * interval1 : (double)margin0 * interval0;
		yMargin = orientation.isVertical() ? (double)margin0 * interval0 : (double)margin1 * interval1;
		pathThickness = params.getPathThickness();
		terminalDiameter = params.getTerminalDiameter();
		expectedPathLength = params.getExpectedPathLength();
		directionProbabilities = params.getDirectionProbabilities();
		directionMode = params.getDirectionMode();
		terminalEmphasis = params.getTerminalEmphasis();
		showEmptyPaths = params.isShowEmptyPaths();
		transparencyColour = params.getTransparencyColour();
		backgroundColour = params.getBackgroundColour();
		pathColours = params.getPathColours();
		activeFraction = params.getActiveFraction();
		transitionIntervalRange = params.getTransitionIntervalRange();
		paths = new ArrayList<>();
		cumulativeProbabilities = getCumulativeProbabilities();
		cumulativeRelativeInverseProbabilitiesCache = new EnumMap<>(Direction.class);

		// Create a list of cumulative probabilities from a Poisson distribution for the expected path
		// length
		if (!pathLengthCumulativeProbabilities.containsKey(expectedPathLength))
		{
			int k = 0;
			double pk = StrictMath.exp((double)-expectedPathLength);
			double cumulativeProb = 0.0;
			List<Double> cds = new ArrayList<>();
			while (cumulativeProb < MAX_CUMULATIVE_PROBABILITY)
			{
				if (k > 0)
					pk *= (double)expectedPathLength / (double)k;
				cumulativeProb += pk;
				cds.add(cumulativeProb);
				++k;
			}
			cds.add(1.0);
			pathLengthCumulativeProbabilities.put(expectedPathLength, cds);
		}

		// Initialise numbers of indices
		int numXDivisions = (int)StrictMath.ceil((double)width / xInterval);
		int numYDivisions = (int)StrictMath.ceil((double)height / yInterval);
		numIndices0 = (orientation.isVertical() ? numYDivisions : numXDivisions) + 2 * margin0 + 1;
		numIndices1 = (orientation.isVertical() ? numXDivisions : numYDivisions) + 2 * margin1 + 1;

		// Fix up margins
		xMargin = 0.5 * ((double)((orientation.isVertical() ? numIndices1 : numIndices0) - 1)
																						* xInterval - (double)width);
		yMargin = 0.5 * ((double)((orientation.isVertical() ? numIndices0 : numIndices1) - 1)
																						* yInterval - (double)height);

		// Initialise arrays of grid indices and vertices
		int[] indices0 = new int[numIndices0];
		for (int i = 0; i < indices0.length; i++)
			indices0[i] = i;
		int[] indices1 = new int[numIndices1];
		for (int i = 0; i < indices1.length; i++)
			indices1[i] = i;
		vertices = new byte[numIndices0][numIndices1];
		for (byte[] v : vertices)
			Arrays.fill(v, (byte)-1);

		// Initialise PRNGs
		prngGeneral = new Prng01(params.getSeed());
		long[] reservedSeeds = new long[NUM_RESERVED_SEEDS];
		for (int i = 0; i < reservedSeeds.length; i++)
			reservedSeeds[i] = prngGeneral.nextInt64();
		prngGeneral = new Prng01(reservedSeeds[PRNG_GENERAL]);
		prngTerminalEmphasis = new Prng01(reservedSeeds[PRNG_TERMINAL_EMPHASIS]);
		prngColour = new Prng01(reservedSeeds[PRNG_COLOUR]);
		animationSeed = reservedSeeds[PRNG_ANIMATION];

		// Generate paths
		for (int index0 : indices0)
		{
			// Test whether task has been cancelled
			if (Thread.interrupted() || Task.isCancelled())
				throw new InterruptedException();

			// Randomise indices 1
			for (int i = indices1.length - 1; i > 0; i--)
			{
				int j = prngGeneral.nextInt(i);
				int temp = indices1[i];
				indices1[i] = indices1[j];
				indices1[j] = temp;
			}

			// Create paths
			for (int index1 : indices1)
			{
				if ((((index0 ^ index1) & 1) == 0) && (vertices[index0][index1] < 0))
				{
					Path path = new Path(index0, index1);
					path.setTerminalEmphasis(terminalEmphasis, prngTerminalEmphasis);
					path.setColour(pathColours, prngColour);
					setInitialVertex(path);
					int length = getNextLength(expectedPathLength, prngGeneral);
					for (int i = 0; i < length; i++)
					{
						Direction direction = getDirection(path.end);
						if (direction == null)
							break;
						path.addDirection(direction);
						setVertex(path.end, direction);
					}
					if (path.isEmpty())
						vertices[index0][index1] = -1;
					else
						paths.add(path);
				}
			}
		}

		// Sort the paths by increasing length
		paths.sort(Path.LENGTH_COMPARATOR);

		// Extend the ends of paths to empty vertices
		boolean changed = true;
		while (changed)
		{
			// Test whether task has been cancelled
			if (Thread.interrupted() || Task.isCancelled())
				throw new InterruptedException();

			// Extend paths
			changed = false;
			for (Path path : paths)
			{
				Direction direction = getDirection(path.end);
				if (direction != null)
				{
					path.addDirection(direction);
					setVertex(path.end, direction);
					changed = true;
				}
			}
		}

		// Extend the starts of paths to empty vertices
		changed = true;
		while (changed)
		{
			// Test whether task has been cancelled
			if (Thread.interrupted() || Task.isCancelled())
				throw new InterruptedException();

			// Extend paths
			changed = false;
			for (Path path : paths)
			{
				Direction direction = getDirection(path.start);
				if (direction != null)
				{
					setVertex(path.start, direction.getInverse());
					path.directions.add(0, direction.getInverse());
					path.start.applyDirection(direction);
					setStartVertex(path, direction);
					changed = true;
				}
			}
		}

		// Create paths at any empty vertices
		List<Path> nonEmptyPaths = paths;
		paths = new ArrayList<>();
		for (int i0 = 0; i0 < numIndices0; i0++)
		{
			for (int i1 = 0; i1 < numIndices1; i1++)
			{
				if ((((i0 ^ i1) & 1) == 0) && (vertices[i0][i1] < 0))
				{
					Path path = new Path(i0, i1);
					path.setTerminalEmphasis(terminalEmphasis, prngTerminalEmphasis);
					path.setColour(pathColours, prngColour);
					paths.add(path);
					setInitialVertex(path);
				}
			}
		}
		paths.addAll(nonEmptyPaths);
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Class methods
////////////////////////////////////////////////////////////////////////

	private static int getNextLength(int    expectedLength,
									 Prng01 prng)
	{
		List<Double> cumulativeProbs = pathLengthCumulativeProbabilities.get(expectedLength);
		int k = 0;
		while (true)
		{
			double u = prng.nextDouble();
			while (true)
			{
				if (u < cumulativeProbs.get(k))
					break;
				++k;
			}
			if (k > 0)
				break;
		}
		return k;
	}

	//------------------------------------------------------------------

	private static int getTotalProbability(Map<Direction, Integer> probabilities)
	{
		int totalProbability = 0;
		for (Direction direction : probabilities.keySet())
		{
			Integer probability = probabilities.get(direction);
			if (probability != null)
				totalProbability += probability;
		}
		return totalProbability;
	}

	//------------------------------------------------------------------

	private static Map<Direction, Double> getCumulativeProbabilities(Map<Direction, Integer> probabilities)
	{
		Map<Direction, Double> cumulativeProbabilities = new EnumMap<>(Direction.class);
		int totalProbability = getTotalProbability(probabilities);
		if (totalProbability > 0)
		{
			Direction lastDirection = null;
			double factor = 1.0 / (double)totalProbability;
			double cumulativeProbability = 0.0;
			for (Direction direction : probabilities.keySet())
			{
				cumulativeProbability += (double)probabilities.get(direction) * factor;
				cumulativeProbabilities.put(direction, cumulativeProbability);
				lastDirection = direction;
			}
			cumulativeProbabilities.put(lastDirection, 1.0);
		}
		return cumulativeProbabilities;
	}

	//------------------------------------------------------------------

	private static Direction getDirection(Map<Direction, Double> cumulativeProbabilities,
										  Prng01                 prng)
	{
		Direction direction = null;
		if (!cumulativeProbabilities.isEmpty())
		{
			while (true)
			{
				double u = prng.nextDouble();
				for (Direction d : cumulativeProbabilities.keySet())
				{
					if (u < cumulativeProbabilities.get(d))
					{
						direction = d;
						break;
					}
				}
				if (direction != null)
					break;
			}
		}
		return direction;
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Instance methods : overriding methods
////////////////////////////////////////////////////////////////////////

	@Override
	public Pattern2Image clone()
	{
		try
		{
			Pattern2Image copy = (Pattern2Image)super.clone();

			copy.directionProbabilities = new EnumMap<>(directionProbabilities);

			copy.transparencyColour = ColourUtils.copy(transparencyColour);

			copy.backgroundColour = ColourUtils.copy(backgroundColour);

			copy.pathColours = new ArrayList<>();
			for (Color colour : pathColours)
				copy.pathColours.add(ColourUtils.copy(colour));

			copy.paths = new ArrayList<>();
			for (Path path : paths)
				copy.paths.add(path.clone());

			copy.vertices = new byte[numIndices0][numIndices1];
			for (int i = 0; i < vertices.length; i++)
				copy.vertices[i] = vertices[i].clone();

			if (image != null)
				copy.image = copyImage(image);

			copy.prngGeneral = null;
			copy.prngTerminalEmphasis = null;
			copy.prngColour = null;

			return copy;
		}
		catch (CloneNotSupportedException e)
		{
			throw new UnexpectedRuntimeException(e);
		}
	}

	//------------------------------------------------------------------

	@Override
	public BufferedImage getImage()
	{
		return image;
	}

	//------------------------------------------------------------------

	@Override
	public BufferedImage getExportImage()
		throws InterruptedException
	{
		return renderImage(null, false);
	}

	//------------------------------------------------------------------

	@Override
	public void renderImage()
		throws InterruptedException
	{
		// Get time at start of rendering
		long startTime = System.nanoTime();

		// Render image
		image = renderImage(image, true);

		// Add rendering time to total
		document.addRenderingTime(width * height, System.nanoTime() - startTime);
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Instance methods
////////////////////////////////////////////////////////////////////////

	public Element createElement(Document document)
	{
		Element element = document.createElement(PatternKind.PATTERN1.getKey());
		for (Attribute attribute : getAttributes())
			attribute.set(element);

		for (Path path : paths)
			element.appendChild(path.createElement(document));

		return element;
	}

	//------------------------------------------------------------------

	public void write(XmlWriter writer,
					  int       indent)
		throws IOException
	{
		String elementName = PatternKind.PATTERN2.getKey();
		writer.writeElementStart(elementName, getAttributes(), indent, true, true);
		for (Path path : paths)
			path.write(writer, indent + XmlWriter.INDENT_INCREMENT);
		writer.writeElementEnd(elementName, indent);
	}

	//------------------------------------------------------------------

	public void writeSvgElements(XmlWriter writer,
								 int       indent)
		throws IOException
	{
		//----  Description

		writer.writeElementStart(Svg.ElementName.DESC, null, indent, false, false);

		writer.write(GENERATED_BY_STR);
		writer.write(PatternGeneratorApp.SHORT_NAME);
		writer.write(' ');
		writer.write(PatternGeneratorApp.INSTANCE.getVersionString());

		writer.writeElementEnd(Svg.ElementName.DESC, 0);


		//----  Definition: clipping path

		// Write definitions element start tag
		writer.writeElementStart(Svg.ElementName.DEFS, null, indent, true, true);
		indent += XmlWriter.INDENT_INCREMENT;

		// Write clipping path element start tag
		AttributeList attributes = new AttributeList();
		attributes.add(Svg.AttrName.ID, CLIP_STR);
		writer.writeElementStart(Svg.ElementName.CLIP_PATH, attributes, indent, true, true);
		indent += XmlWriter.INDENT_INCREMENT;

		// Write clipping rectangle element
		attributes.clear();
		attributes.add(Svg.AttrName.WIDTH, width);
		attributes.add(Svg.AttrName.HEIGHT, height);
		writer.writeEmptyElement(Svg.ElementName.RECT, attributes, indent, true);

		// Write clipping path element end tag
		indent -= XmlWriter.INDENT_INCREMENT;
		writer.writeElementEnd(Svg.ElementName.CLIP_PATH, indent);


		//----  Definition: style of paths

		// Write style element start tag
		attributes.clear();
		attributes.add(Svg.AttrName.ID, PATH_STYLE_STR);
		attributes.add(Svg.AttrName.TYPE, TEXT_CSS_STR);
		writer.writeElementStart(Svg.ElementName.STYLE, attributes, indent, true, true);

		// Write style
		for (String str : PATH_STYLE_STRS)
		{
			writer.writeSpaces(indent + XmlWriter.INDENT_INCREMENT);
			writer.write(String.format(str, OutputShape.FORMAT.format(pathThickness)));
			writer.writeEol();
		}

		// Write style element end tag
		writer.writeElementEnd(Svg.ElementName.STYLE, indent);

		// Write definitions element end tag
		indent -= XmlWriter.INDENT_INCREMENT;
		writer.writeElementEnd(Svg.ElementName.DEFS, indent);


		//----  Group: background

		// Write background group element start tag
		attributes.clear();
		attributes.add(Svg.AttrName.ID, BACKGROUND_STR);
		writer.writeElementStart(Svg.ElementName.G, attributes, indent, true, true);
		indent += XmlWriter.INDENT_INCREMENT;

		// Write background rectangle element
		attributes.clear();
		attributes.add(Svg.AttrName.FILL, ColourUtils.colourToHexString(backgroundColour));
		if (ColourUtils.isTransparent(backgroundColour))
		{
			attributes.add(Svg.AttrName.FILL_OPACITY, ColourUtils.getOpacity(backgroundColour),
						   ColourUtils.OPACITY_FORMAT);
		}
		attributes.add(Svg.AttrName.WIDTH, width);
		attributes.add(Svg.AttrName.HEIGHT, height);
		writer.writeEmptyElement(Svg.ElementName.RECT, attributes, indent, true);

		// Write background group element end tag
		indent -= XmlWriter.INDENT_INCREMENT;
		writer.writeElementEnd(Svg.ElementName.G, indent);


		//----  Group: foreground

		// Write foreground group element start tag
		attributes.clear();
		attributes.add(Svg.AttrName.ID, FOREGROUND_STR);
		attributes.add(Svg.AttrName.CLIP_PATH, CLIP_PATH_REF_STR);
		writer.writeElementStart(Svg.ElementName.G, attributes, indent, true, true);
		indent += XmlWriter.INDENT_INCREMENT;

		// Write shapes
		AffineTransform transform = getTransform();
		for (OutputShape shape : createOutputShapes())
		{
			shape.transform(transform);
			shape.writeSvg(writer, indent);
		}

		// Write foreground group element end tag
		indent -= XmlWriter.INDENT_INCREMENT;
		writer.writeElementEnd(Svg.ElementName.G, indent);
	}

	//------------------------------------------------------------------

	public void initAnimation(int startFrameIndex)
		throws InterruptedException
	{
		// Initialise PRNGs
		prngGeneral = new Prng01(animationSeed);
		long[] reservedSeeds = new long[NUM_RESERVED_SEEDS];
		for (int i = 0; i < reservedSeeds.length; i++)
			reservedSeeds[i] = prngGeneral.nextInt64();
		prngGeneral = new Prng01(reservedSeeds[PRNG_GENERAL]);
		prngTerminalEmphasis = new Prng01(reservedSeeds[PRNG_TERMINAL_EMPHASIS]);
		prngColour = new Prng01(reservedSeeds[PRNG_COLOUR]);
		prngTransitionLength = new Prng01(reservedSeeds[PRNG_TRANSITION_LENGTH]);

		// Update paths until first frame of animation
		IProgressView progressView = Task.getProgressView();
		int frameIndex = 0;
		while (frameIndex < startFrameIndex)
		{
			// Test whether task has been cancelled
			if (Task.isCancelled())
				throw new InterruptedException();

			// Update paths
			updatePaths(frameIndex++);

			// Update progress view
			if (progressView != null)
				progressView.setProgress(0, (double)frameIndex / (double)startFrameIndex);
		}
	}

	//------------------------------------------------------------------

	public void updatePaths(int frameIndex)
		throws InterruptedException
	{
		final	int		INACTIVITY_THRESHOLD	= 1000;

		final	double	EXPONENTIAL_DIST_LAMBDA	= 1.0;
		final	double	EXPONENTIAL_DIST_FACTOR	= 0.6;

		// Update path terminals
		Iterator<Path> it = paths.iterator();
		while (it.hasNext())
		{
			if (it.next().update(frameIndex))
				it.remove();
		}

		// Create a list of paths that are candidates for lengthening, and count the number of active paths
		List<Path> candidatePaths = new ArrayList<>();
		int numActivePaths = 0;
		for (Path path : paths)
		{
			if ((path.start.change == Path.Change.NONE) || (path.end.change == Path.Change.NONE))
				candidatePaths.add(path);
			if (path.isChanging())
				++numActivePaths;
		}

		// Sort the paths by increasing length
		candidatePaths.sort(Path.LENGTH_COMPARATOR);

		// Lengthen selected paths
		while (!candidatePaths.isEmpty())
		{
			// Test whether task has been cancelled
			if (Thread.interrupted() || Task.isCancelled())
			{
				image = null;
				throw new InterruptedException();
			}

			// Test whether the required fraction of paths are active
			double fraction = (double)numActivePaths / (double)paths.size();
			if ((int)StrictMath.round(fraction * ACTIVE_FRACTION_FACTOR) >= activeFraction)
				break;

			// Select a path
			Path path = null;
			while (path == null)
			{
				double exp = prngGeneral.nextExponential(EXPONENTIAL_DIST_LAMBDA) * EXPONENTIAL_DIST_FACTOR;
				int index = (int)StrictMath.floor(exp * (double)candidatePaths.size());
				if (index < candidatePaths.size())
					path = candidatePaths.remove(index);
			}

			// Select the start or end of the path
			int change = 0;
			if (path.start.change == Path.Change.NONE)
				change |= (1 << 0);
			if (path.end.change == Path.Change.NONE)
				change |= (1 << 1);

			Path.Terminal.Kind terminalKind = null;
			switch (change)
			{
				case 1:
					terminalKind = Path.Terminal.Kind.START;
					break;

				case 2:
					terminalKind = Path.Terminal.Kind.END;
					break;

				case 3:
					terminalKind = prngGeneral.nextBoolean() ? Path.Terminal.Kind.START : Path.Terminal.Kind.END;
					break;
			}
			if (terminalKind == null)
				continue;

			// Create a map of probabilities for valid directions
			Map<Direction, Path.Terminal> shortenTerminals = new EnumMap<>(Direction.class);
			Path.Terminal terminal = (terminalKind == Path.Terminal.Kind.START) ? path.start : path.end;
			Map<Direction, Integer> probabilities = getDirectionProbabilities(terminal);
			for (Direction direction : probabilities.keySet())
			{
				int i0 = direction.incrementIndex0(terminal.i0);
				int i1 = direction.incrementIndex1(terminal.i1);
				boolean valid = false;
				if (vertices[i0][i1] < 0)
					valid = true;
				else
				{
					for (Path path1 : paths)
					{
						if ((path1 != path) && (path1.start.change != Path.Change.SHORTEN)
							&& (path1.end.change != Path.Change.SHORTEN))
						{
							if ((path1.start.change == Path.Change.NONE) && path1.start.isAt(i0, i1))
							{
								valid = true;
								shortenTerminals.put(direction, path1.start);
								break;
							}
							if ((path1.end.change == Path.Change.NONE) && path1.end.isAt(i0, i1))
							{
								valid = true;
								shortenTerminals.put(direction, path1.end);
								break;
							}
						}
					}
				}
				if (!valid)
					probabilities.remove(direction);
			}

			// Get a random direction based on cumulative probabilities
			Direction direction = getDirection(getCumulativeProbabilities(probabilities), prngGeneral);

			// Conditionally split or shorten a path that cannot be lengthened ...
			if (direction == null)
			{
				// Split the path if its length is more than twice the expected path length or it extends
				// across the whole grid
				int pathLength = path.getLength();
				if ((path.end.change == Path.Change.NONE) && (pathLength > 2) &&
					 ((pathLength > 2 * expectedPathLength) ||
					  ((path.start.i0 == getFirstIndex0(path.start.i1)) &&
														(path.end.i0 == getLastIndex0(path.end.i1))) ||
					  ((path.end.i0 == getFirstIndex0(path.end.i1)) &&
													(path.start.i0 == getLastIndex0(path.start.i1))) ||
					  ((path.start.i1 == 0) && (path.end.i1 == numIndices1 - 1)) ||
					  ((path.end.i1 == 0) && (path.start.i1 == numIndices1 - 1))))
				{
					// Generate a variate from a triangular distribution to use as the split point
					int splitLength = 1;
					if (pathLength > 3)
					{
						double a = 1.0;
						double b = (double)pathLength - 2.0;
						double c = (double)pathLength * 0.5;
						double fc = (c - a) / (b - a);
						double u = prngGeneral.nextDouble();
						double value = (u < fc) ? a + StrictMath.sqrt(u * (b - a) * (c - a))
												: b - StrictMath.sqrt((1.0 - u) * (b - a) * (b - c));
						splitLength = (int)StrictMath.round(value);
					}

					// Get the grid indices of the split point
					int i0 = path.start.i0;
					int i1 = path.start.i1;
					for (int i = 0; i < splitLength; i++)
					{
						direction = path.directions.get(i);
						i0 = direction.incrementIndex0(i0);
						i1 = direction.incrementIndex1(i1);
					}

					// Create a new path
					Path newPath = new Path(i0, i1);
					for (int i = splitLength; i < pathLength; i++)
						newPath.addDirection(path.directions.get(i));
					newPath.setTerminalEmphasis(terminalEmphasis, prngTerminalEmphasis);
					newPath.colour = path.colour;
					paths.add(newPath);

					// Shorten the old path
					path.directions = path.directions.subList(0, splitLength);
					path.end.i0 = newPath.start.i0;
					path.end.i1 = newPath.start.i1;

					// Shorten the new path
					newPath.start.shorten(frameIndex, getTransitionLength(), newPath.getFirstDirection());
					++numActivePaths;
				}

				// ... otherwise, shorten the path if it has been inactive for a while
				else if (!path.isEmpty())
				{
					int lastActivityFrameIndex =
												StrictMath.max(path.start.startFrameIndex + path.start.transitionLength,
															   path.end.startFrameIndex + path.end.transitionLength);
					if (frameIndex - lastActivityFrameIndex > INACTIVITY_THRESHOLD)
					{
						direction = (terminalKind == Path.Terminal.Kind.START) ? path.getFirstDirection()
																			   : path.getLastDirection().getInverse();
						terminal.shorten(frameIndex, getTransitionLength(), direction);
						vertices[terminal.i0][terminal.i1] = -1;
						++numActivePaths;
					}
				}
			}

			// ... otherwise, lengthen the path
			else
			{
				// Generate the transition interval
				int transitionLength = getTransitionLength();

				// Shorten the destination path
				Path.Terminal terminal1 = shortenTerminals.get(direction);
				if (terminal1 != null)
				{
					Path path1 = terminal1.path;
					if (!path1.isChanging())
						++numActivePaths;
					if (path1.isEmpty())
						path1.destroy(frameIndex, transitionLength);
					else
					{
						Direction direction1 = (terminal1.kind == Path.Terminal.Kind.START)
																		? path1.getFirstDirection()
																		: path1.getLastDirection().getInverse();
						terminal1.shorten(frameIndex, transitionLength, direction1);
					}
				}

				// Lengthen the path
				if (!path.isChanging())
					++numActivePaths;
				if (terminalKind == Path.Terminal.Kind.START)
				{
					setVertex(path.start, direction.getInverse());
					path.start.lengthen(frameIndex, transitionLength, direction);
					path.directions.add(0, direction.getInverse());
					setStartVertex(path, direction);
				}
				else
				{
					path.end.lengthen(frameIndex, transitionLength, direction);
					path.directions.add(direction);
					setVertex(path.end, direction);
				}
			}
		}

		// Create paths at any empty vertices
		for (int i0 = 0; i0 < numIndices0; i0++)
		{
			for (int i1 = 0; i1 < numIndices1; i1++)
			{
				if ((((i0 ^ i1) & 1) == 0) && (vertices[i0][i1] < 0))
				{
					Path path = new Path(i0, i1);
					path.setTerminalEmphasis(terminalEmphasis, prngTerminalEmphasis);
					path.setColour(pathColours, prngColour);
					path.create(frameIndex, getTransitionLength());
					paths.add(path);
					setInitialVertex(path);
				}
			}
		}
	}

	//------------------------------------------------------------------

	private AttributeList getAttributes()
	{
		AttributeList attributes = new AttributeList();
		attributes.add(AttrName.VERSION, VERSION);
		if (description != null)
			attributes.add(AttrName.DESCRIPTION, description, true);
		attributes.add(AttrName.WIDTH, width);
		attributes.add(AttrName.HEIGHT, height);
		attributes.add(AttrName.ORIENTATION, orientation.getKey());
		attributes.add(AttrName.X_INTERVAL, xInterval, AppConstants.FORMAT_1_8);
		attributes.add(AttrName.Y_INTERVAL, yInterval, AppConstants.FORMAT_1_8);
		attributes.add(AttrName.X_MARGIN, xMargin, AppConstants.FORMAT_1_8);
		attributes.add(AttrName.Y_MARGIN, yMargin, AppConstants.FORMAT_1_8);
		attributes.add(AttrName.PATH_THICKNESS, pathThickness, AppConstants.FORMAT_1_8);
		attributes.add(AttrName.TERMINAL_DIAMETER, terminalDiameter, AppConstants.FORMAT_1_8);
		attributes.add(AttrName.SHOW_EMPTY_PATHS, showEmptyPaths);
		attributes.add(AttrName.TRANSPARENCY_COLOUR, ColourUtils.colourToRgbString(transparencyColour));
		attributes.add(AttrName.BACKGROUND_COLOUR, ColourUtils.colourToRgbString(backgroundColour));
		attributes.add(AttrName.NUM_PATHS, paths.size());
		return attributes;
	}

	//------------------------------------------------------------------

	private int getFirstIndex0(int i1)
	{
		return (i1 & 1);
	}

	//------------------------------------------------------------------

	private int getLastIndex0(int i1)
	{
		int i0 = numIndices0 - 1;
		return ((((i0 ^ i1) & 1) == 0) ? i0 : i0 - 1);
	}

	//------------------------------------------------------------------

	private void setVertex(Path.Terminal terminal,
						   Direction     direction)
	{
		vertices[terminal.i0][terminal.i1] = (byte)direction.ordinal();
	}

	//------------------------------------------------------------------

	private void setInitialVertex(Path path)
	{
		setVertex(path.start,
				  getDirection((directionMode == Direction.Mode.RELATIVE) ? CUMULATIVE_EQUAL_PROBABILITIES
																		  : cumulativeProbabilities,
							   prngGeneral));
	}

	//------------------------------------------------------------------

	private void setStartVertex(Path      path,
								Direction direction)
	{
		setVertex(path.start,
				  getDirection((directionMode == Direction.Mode.RELATIVE)
													? getCumulativeRelativeInverseProbabilities(direction)
													: cumulativeProbabilities,
							   prngGeneral));
	}

	//------------------------------------------------------------------

	private AffineTransform getTransform()
	{
		// Get x factor and term
		double m00 = 1.0;
		double m02 = -xMargin;
		if (orientation == Orientation.LEFT)
		{
			m00 = -1.0;
			m02 = (double)width + xMargin;
		}

		// Get y factor and term
		double m11 = -1.0;
		double m12 = (double)height + yMargin;
		if (orientation == Orientation.DOWN)
		{
			m11 = 1.0;
			m12 = -yMargin;
		}

		return new AffineTransform(m00, 0.0, 0.0, m11, m02, m12);
	}

	//------------------------------------------------------------------

	private int getTransitionLength()
	{
		return (transitionIntervalRange.lowerBound
												+ prngTransitionLength.nextInt(transitionIntervalRange.getInterval()));

	}

	//------------------------------------------------------------------

	private Map<Direction, Integer> getDirectionProbabilities(Path.Terminal pathTerminal)
	{
		Map<Direction, Integer> probabilities = new EnumMap<>(Direction.class);
		boolean isStart = (pathTerminal.kind == Path.Terminal.Kind.START);
		Direction currDirection = pathTerminal.path.isEmpty()
										? Direction.values()[vertices[pathTerminal.i0][pathTerminal.i1]]
										: isStart ? pathTerminal.path.getFirstDirection().getInverse()
												  : pathTerminal.path.getLastDirection();
		for (Direction direction : directionProbabilities.keySet())
		{
			Integer probability = directionProbabilities.get(direction);
			if ((probability != null) && (probability > 0))
			{
				// Convert direction according to direction mode and terminal kind
				if (directionMode == Direction.Mode.ABSOLUTE)
				{
					if (isStart)
						direction = direction.getInverse();
				}
				else
					direction = isStart ? currDirection.subtract(direction)
										: currDirection.add(direction);

				// Add probability to map if destination of direction is within bounds
				int i0 = direction.incrementIndex0(pathTerminal.i0);
				int i1 = direction.incrementIndex1(pathTerminal.i1);
				if ((i0 >= 0) && (i0 < numIndices0) && (i1 >= 0) && (i1 < numIndices1))
					probabilities.put(direction, probability);
			}
		}
		return probabilities;
	}

	//------------------------------------------------------------------

	private Map<Direction, Double> getCumulativeProbabilities()
	{
		// Create a map of probabilities
		Map<Direction, Integer> probabilities = new EnumMap<>(Direction.class);
		for (Direction direction : directionProbabilities.keySet())
		{
			Integer probability = directionProbabilities.get(direction);
			if ((probability != null) && (probability > 0))
				probabilities.put(direction, probability);
		}

		// Return cumulative probabilities
		return getCumulativeProbabilities(probabilities);
	}

	//------------------------------------------------------------------

	private Map<Direction, Double> getCumulativeRelativeInverseProbabilities(Direction baseDirection)
	{
		// Get cumulative probabilities from the cache
		Map<Direction, Double> cumulativeProbabilities = cumulativeRelativeInverseProbabilitiesCache.get(baseDirection);

		// If not cached, create a map of cumulative probabilities
		if (cumulativeProbabilities == null)
		{
			// Create a map of relative inverse probabilities
			Map<Direction, Integer> probabilities = new EnumMap<>(Direction.class);
			for (Direction direction : directionProbabilities.keySet())
			{
				Integer probability = directionProbabilities.get(direction);
				if ((probability != null) && (probability > 0))
					probabilities.put(baseDirection.subtract(direction.getInverse()), probability);
			}

			// Get cumulative probabilities
			cumulativeProbabilities = getCumulativeProbabilities(probabilities);

			// Put cumulative probabilities in the cache
			cumulativeRelativeInverseProbabilitiesCache.put(baseDirection, cumulativeProbabilities);
		}

		// Return cumulative probabilities
		return cumulativeProbabilities;
	}

	//------------------------------------------------------------------

	private Direction getDirection(Path.Terminal pathTerminal)
	{
		// Create a map of probabilities
		Map<Direction, Integer> probabilities = getDirectionProbabilities(pathTerminal);

		// Remove blocked directions from the map
		for (Direction direction : probabilities.keySet())
		{
			int i0 = direction.incrementIndex0(pathTerminal.i0);
			int i1 = direction.incrementIndex1(pathTerminal.i1);
			if (vertices[i0][i1] >= 0)
				probabilities.remove(direction);
		}

		// Create a map of cumulative probabilities and return a randomly generated direction using the map
		return getDirection(getCumulativeProbabilities(probabilities), prngGeneral);
	}

	//------------------------------------------------------------------

	private List<OutputShape> createOutputShapes()
	{
		List<OutputShape> outShapes = new ArrayList<>();

		// Process empty paths
		boolean verticalOrientation = orientation.isVertical();
		if (showEmptyPaths)
		{
			for (Path path : paths)
			{
				// Add terminal disc
				if (path.isEmpty())
				{
					// Set colour
					Color colour = null;
					switch (path.start.change)
					{
						case NONE:
							colour = path.colour;
							break;

						case LENGTHEN:
							colour = ColourUtils.interpolateHsb(backgroundColour, path.colour,
																path.start.changeFraction);
							break;

						case SHORTEN:
							colour = ColourUtils.interpolateHsb(path.colour, backgroundColour,
																path.start.changeFraction);
							break;
					}

					// Add disc
					double x = (double)(verticalOrientation ? path.start.i1 : path.start.i0) * xInterval;
					double y = (double)(verticalOrientation ? path.start.i0 : path.start.i1) * yInterval;
					double diameter = pathThickness;
					if ((path.start.emphasise || path.end.emphasise) && (diameter < terminalDiameter))
						diameter = terminalDiameter;
					outShapes.add(new OutputShape.Disc(colour, x, y, diameter));
				}
			}
		}

		// Process non-empty paths
		for (Path path : paths)
		{
			// Add path
			if (!path.isEmpty())
			{
				// Initialise path indices and coordinates
				int i0 = path.start.i0;
				int i1 = path.start.i1;
				double x = 0.0;
				double y = 0.0;
				if (path.start.change != Path.Change.NONE)
				{
					x = (verticalOrientation ? path.start.if1 : path.start.if0) * xInterval;
					y = (verticalOrientation ? path.start.if0 : path.start.if1) * yInterval;
				}
				else
				{
					x = (double)(verticalOrientation ? i1 : i0) * xInterval;
					y = (double)(verticalOrientation ? i0 : i1) * yInterval;
				}

				// Add disc at start of path
				if (path.start.emphasise && (terminalDiameter > pathThickness))
					outShapes.add(new OutputShape.Disc(path.colour, x, y, terminalDiameter));

				// Create polyline
				OutputShape.Polyline polyline = new OutputShape.Polyline(path.colour, x, y);
				for (int i = 0; i < path.getLength(); i++)
				{
					if ((i == path.getLength() - 1) && (path.end.change != Path.Change.NONE))
					{
						x = (verticalOrientation ? path.end.if1 : path.end.if0) * xInterval;
						y = (verticalOrientation ? path.end.if0 : path.end.if1) * yInterval;
					}
					else
					{
						Direction direction = path.directions.get(i);
						i0 = direction.incrementIndex0(i0);
						i1 = direction.incrementIndex1(i1);
						x = (double)(verticalOrientation ? i1 : i0) * xInterval;
						y = (double)(verticalOrientation ? i0 : i1) * yInterval;
					}
					polyline.add(x, y);
				}
				outShapes.add(polyline);

				// Add disc at end of path
				if (path.end.emphasise && (terminalDiameter > pathThickness))
					outShapes.add(new OutputShape.Disc(path.colour, x, y, terminalDiameter));
			}
		}

		return outShapes;
	}

	//------------------------------------------------------------------

	/**
	 * Renders the pattern image by drawing in a BufferedImage object using Java 2D methods.  No provision
	 * has been made for rendering the Path objects from multiple threads because Java 2D uses
	 * single-threaded rendering in Java SE 6.
	 */

	private BufferedImage renderImage(BufferedImage image,
									  boolean       opaque)
		throws InterruptedException
	{
		// Create buffered image, if necessary
		if (image == null)
			image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);

		// Create graphics context for image
		Graphics2D gr = image.createGraphics();
		gr.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		gr.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
		gr.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,
							AppConfig.INSTANCE.getPattern2PathRendering().renderingHintValue);

		gr.setStroke(new BasicStroke((float)pathThickness, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));

		// Fill background
		gr.setColor((opaque && ColourUtils.isTransparent(backgroundColour))
													? ColourUtils.blend(backgroundColour, transparencyColour)
													: backgroundColour);
		gr.fillRect(0, 0, width, height);

		// Apply pattern orientation to graphics context
		gr.transform(getTransform());

		// Draw paths
		try
		{
			drawPaths(gr);
		}
		catch (InterruptedException e)
		{
			image = null;
			throw e;
		}

		// Return image
		return image;
	}

	//------------------------------------------------------------------

	private void drawPaths(Graphics2D gr)
		throws InterruptedException
	{
		for (OutputShape shape : createOutputShapes())
		{
			// Test whether task has been cancelled
			if (Thread.interrupted() || Task.isCancelled())
				throw new InterruptedException();

			// Draw shape
			shape.draw(gr);
		}
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Class variables
////////////////////////////////////////////////////////////////////////

	private static	Map<Integer, List<Double>>	pathLengthCumulativeProbabilities	= new HashMap<>();

////////////////////////////////////////////////////////////////////////
//  Static initialiser
////////////////////////////////////////////////////////////////////////

	static
	{
		Map<Direction, Integer> probabilities = new EnumMap<>(Direction.class);
		for (Direction direction : Direction.values())
			probabilities.put(direction, 1);
		CUMULATIVE_EQUAL_PROBABILITIES = getCumulativeProbabilities(probabilities);
	}

////////////////////////////////////////////////////////////////////////
//  Instance variables
////////////////////////////////////////////////////////////////////////

	private	Pattern2Document						document;
	private	Orientation								orientation;
	private	double									xInterval;
	private	double									yInterval;
	private	double									xMargin;
	private	double									yMargin;
	private	int										numIndices0;
	private	int										numIndices1;
	private	double									pathThickness;
	private	double									terminalDiameter;
	private	int										expectedPathLength;
	private	Map<Direction, Integer>					directionProbabilities;
	private	Direction.Mode							directionMode;
	private	TerminalEmphasis						terminalEmphasis;
	private	boolean									showEmptyPaths;
	private	Color									transparencyColour;
	private	Color									backgroundColour;
	private	List<Color>								pathColours;
	private	int										activeFraction;
	private	IntegerRange							transitionIntervalRange;
	private	List<Path>								paths;
	private	Map<Direction, Double>					cumulativeProbabilities;
	private	Map<Direction, Map<Direction, Double>>	cumulativeRelativeInverseProbabilitiesCache;
	private	byte[][]								vertices;
	private	BufferedImage							image;
	private	long									animationSeed;
	private	Prng01									prngGeneral;
	private	Prng01									prngTerminalEmphasis;
	private	Prng01									prngColour;
	private	Prng01									prngTransitionLength;

}

//----------------------------------------------------------------------
